name: Hog-main

on:
  workflow_call:
    inputs:
      HOG_CREATE_OFFICIAL_RELEASE:
        required: false
        type: boolean
      HOG_OFFICIAL_BIN_EOS_PATH:
        type: string
        required: false
      HOG_USE_DOXYGEN:
        required: false
        type: boolean
      HOG_CHECK_PROJVER:
        required: false
        type: boolean
      HOG_TARGET_BRANCH:
        required: false
        type: string
    secrets:
      SUBMODULE_CONTENT_PULL_KEY:
        required: true
      HOG_PUSH_TOKEN:
        required: true
      HOG_EMAIL:
        required: true
      HOG_USER:
        required: true
      EOS_PASSWORD:
        required: false
      EOS_USER:
        required: false
      EOS_MGM_URL:
        required: false
        
env:
  HOG_PUSH_TOKEN: ${{ secrets.HOG_PUSH_TOKEN }}
  HOG_USER: ${{ secrets.HOG_USER }}
  HOG_EMAIL: ${{ secrets.HOG_EMAIL }}
  EOS_USER: ${{ secrets.EOS_USER}}
  EOS_PASSWORD: ${{ secrets.EOS_PASSWORD}}

jobs:
  tag_official_version:
    runs-on: ubuntu-latest
    container: gitlab-registry.cern.ch/hog/hog-docker:tclsh
    outputs:
      tag: ${{ steps.tag.outputs.tag }}
      runid: ${{ steps.tag.outputs.runid}}
    steps:
      - uses: actions/checkout@v2
        with: 
          fetch-depth: 0
      - uses: webfactory/ssh-agent@v0.5.4
        with:
            ssh-private-key: ${{ secrets.SUBMODULE_CONTENT_PULL_KEY }}
      - name: tag_official_version
        id: tag
        run: |
          git config --global user.email "$HOG_EMAIL"
          git config --global user.name "$HOG_USER"
          git fetch 
          git checkout $GITHUB_HEAD_REF
          git pull
          commit_message=$(git show --pretty=format:"%B" --no-patch)
          echo "Removing merge commit..."
          echo "Current commit is $(git rev-parse HEAD)"
          echo "Reverting to $(git log -n 1 --skip 1 --pretty=format:"%H")"
          previous_commit=$(git log -n 1 --skip 1 --pretty=format:"%H")  
          git reset --hard $previous_commit
          git push --force
          git fetch origin refs/notes/*:refs/notes/*
          note=(`git notes show`)
          new_tag=${note[2]}
          if [ "$(git tag --list ${new_tag}*)" != "" ]; then
            latest_tag=(`git tag -l ${new_tag}* --sort=-v:refname --merged`);
            if [[ $latest_tag =~ ".*-(.*)" ]]; then
              nr="${BASH_REMATCH[1]}";
              new_tag="$new_tag-$(($nr+1))";
            else
              new_tag="$new_tag-0";
            fi;
          fi;
          git tag $new_tag -m "Official_version_${new_tag}" 
          git push --tags
          echo "::set-output name=tag::$new_tag"
          echo "::set-output name=runid::${note[0]}"
  archive_binary_files:
    runs-on: ubuntu-latest
    if: ${{ inputs.HOG_OFFICIAL_BIN_EOS_PATH != '' }}
    needs: [tag_official_version]
    container: gitlab-registry.cern.ch/hog/hog-docker:tclsh
    steps:
      - uses: actions/checkout@v2
        with: 
          fetch-depth: 0
      - uses: webfactory/ssh-agent@v0.5.4
        with:
            ssh-private-key: ${{ secrets.SUBMODULE_CONTENT_PULL_KEY }}
      - name: Get Artifacts
        run: |
          git config --global user.email "$HOG_EMAIL"
          git config --global user.name "$HOG_USER"
          git fetch 
          git checkout $GITHUB_HEAD_REF
          git pull
          git submodule init
          git submodule update
          if [[ "${{ inputs.HOG_OFFICIAL_BIN_EOS_PATH }}" != "" ]]; then
            until echo $EOS_PASSWORD | kinit $EOS_USER@CERN.CH; do
            echo Retrying;
            sleep 2;
            done;
          fi;
          if [ -v "${{ secrets.EOS_MGM_URL}}" ]; then
            export EOS_MGM_URL=${{ secrets.EOS_MGM_URL }}
          else
            export EOS_MGM_URL="root://eosuser.cern.ch"
          fi;
          if [[ "${{ inputs.HOG_USE_DOXYGEN }}" == "1" ]]; then
            ./Hog/Other/GetArtifactsAndRename.sh -token $HOG_PUSH_TOKEN -url $GITHUB_API_URL -proj_id $GITHUB_REPOSITORY -mr ${{ needs.tag_official_version.outputs.runid}} -doxygen -github ;
            if [[ "${{ inputs.HOG_OFFICIAL_BIN_EOS_PATH }}" != "" ]]; then
              echo "Copying Doxygen documentation to ${{inputs.HOG_OFFICIAL_BIN_EOS_PATH}}/Doc";
              eos mkdir -p ${{ inputs.HOG_OFFICIAL_BIN_EOS_PATH }}/Doc;
              xrdcp -rsf Doc/html/* ${EOS_MGM_URL}/${{inputs.HOG_OFFICIAL_BIN_EOS_PATH}}/Doc;
            fi;
          else
            ./Hog/Other/GetArtifactsAndRename.sh -token $HOG_PUSH_TOKEN -url $GITHUB_API_URL -proj_id $GITHUB_REPOSITORY -mr ${{ needs.tag_official_version.outputs.runid}} -github;
          fi
          if [[ "${{ inputs.HOG_OFFICIAL_BIN_EOS_PATH }}" != "" ]]; then
            echo "Copying binary files to ${{inputs.HOG_OFFICIAL_BIN_EOS_PATH}}/${{ needs.tag_official_version.outputs.tag }}";
            eos mkdir ${{inputs.HOG_OFFICIAL_BIN_EOS_PATH}}/${{ needs.tag_official_version.outputs.tag }};
            xrdcp -rfs bin/* ${EOS_MGM_URL}//${{inputs.HOG_OFFICIAL_BIN_EOS_PATH}}/${{ needs.tag_official_version.outputs.tag }};
          fi;
  create_github_release:
    runs-on: ubuntu-latest
    needs: [tag_official_version]
    container: gitlab-registry.cern.ch/hog/hog-docker:tclsh
    if: ${{ inputs.HOG_CREATE_OFFICIAL_RELEASE }}
    steps:
      - uses: actions/checkout@v2
        with: 
          fetch-depth: 0
      - uses: webfactory/ssh-agent@v0.5.4
        with:
            ssh-private-key: ${{ secrets.SUBMODULE_CONTENT_PULL_KEY }}
      - name: Get Artifacts
        run: |
          git config --global user.email "$HOG_EMAIL"
          git config --global user.name "$HOG_USER"
          git fetch
          git checkout -f $GITHUB_REF_NAME
          git pull
          git submodule init
          git submodule update
          ./Hog/Other/GetArtifactsAndRename.sh -token $HOG_PUSH_TOKEN -url $GITHUB_API_URL -proj_id $GITHUB_REPOSITORY -mr ${{ needs.tag_official_version.outputs.runid}} -github;         
          zip -r binaries.zip bin
      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # This token is provided by Actions, you do not need to create your own token
        with:
          tag_name: ${{ needs.tag_official_version.outputs.tag }}
          release_name: Release ${{ needs.tag_official_version.outputs.tag }}
          body_path: bin/note.md
          draft: false
          prerelease: false
      - name: Upload Release Asset
        id: upload-release-asset 
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }} # This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps 
          asset_path: ./binaries.zip
          asset_name: Binaries
          asset_content_type: application/zip
